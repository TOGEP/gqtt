package broker

import (
	"sync"
)

const (
	multiLevelWildcard  = "#"
	singleLevelWildcard = "+"
)

type Topic struct {
	ClientId string
	Names    []string
}

type TopicTree struct {
	name      string
	clients   []string
	wildcards []string
	Children  map[string]*TopicTree

	mu sync.Mutex
}

func NewTopicTree(name string) *TopicTree {
	return &TopicTree{
		name:      name,
		clients:   make([]string, 0),
		wildcards: make([]string, 0),
		Children:  make(map[string]*TopicTree),
	}
}

func (t *TopicTree) Clients() []string {
	// explicit copy slice
	return append([]string{}, t.clients...)
}

func (t *TopicTree) FindOrCreate(paths []string) *TopicTree {
	p := paths[0]
	var child *TopicTree
	if c, ok := t.Children[p]; ok {
		child = c
	} else {
		child = NewTopicTree(p)
		t.Children[p] = child
	}

	if len(paths) == 1 {
		return child
	}
	return child.FindOrCreate(paths[1:])
}

func (t *TopicTree) Find(paths []string) *TopicTree {
	p := paths[0]
	var child *TopicTree
	if c, ok := t.Children[p]; ok {
		child = c
	} else {
		return nil
	}

	if len(paths) == 1 {
		return child
	}
	return child.FindOrCreate(paths[1:])
}

func (t *TopicTree) FindClients(paths []string, stack []string) []string {
	if stack == nil {
		stack = []string{}
	}

	p := paths[0]
	var child *TopicTree
	if c, ok := t.Children[p]; ok {
		child = c
	} else {
		return nil
	}

	if len(paths) == 1 {
		return child
	}
	return child.FindOrCreate(paths[1:])
	return []string{}
}

func (t *TopicTree) Subscribe(clientId string) {
	t.mu.Lock()
	defer t.mu.Unlock()

	var child *TopicTree
	p := paths[0]

	// Special wildcard path for "*" or "+"
	if p == multiLevelWildcard || p == singleLevelWildcard {
		for _, c := range t.Children {
			c.clients = append(c.clients, clientId)
			// only singleLevelWildcard allows to subscribe sub-path
			if len(paths) > 1 && p == singleLevelWildcard {
				c.Subscribe(paths[1:], clientId)
			}
		}
		return
	}

	if c, ok := t.Children[p]; ok {
		child = c
	} else {
		child = NewTopicTree(p)
		t.Children[p] = child
	}

	if len(paths) == 1 {
		return child
	} else if paths[1] == "#" {
		child.clients = append(child.clients, clientId)
	}
	return child.FindOrCreate(paths[1:])

	t.clients = append(t.clients, clientId)
}

func (t *TopicTree) Unsubscribe(clientId string) {
	t.mu.Lock()
	defer t.mu.Unlock()

	idx := -1
	for i, id := range t.clients {
		if id == clientId {
			idx = i
		}
	}
	switch {
	case idx == 0:
		t.clients = t.clients[1:]
	case idx == len(t.clients)-1:
		t.clients = t.clients[:idx]
	case idx == -1:
		break
	default:
		t.clients = append(t.clients[:idx], t.clients[idx+1:]...)
	}
}
